
<!DOCTYPE html>


<!--[if IEMobile 7]><html class="iem7 no-js"  lang="en" dir="ltr"><![endif]-->
<!--[if lte IE 6]><html class="lt-ie9 lt-ie8 lt-ie7 no-js"  lang="en" dir="ltr"><![endif]-->
<!--[if (IE 7)&(!IEMobile)]><html class="lt-ie9 lt-ie8 no-js"  lang="en" dir="ltr"><![endif]-->
<!--[if IE 8]><html class="lt-ie9 no-js"  lang="en" dir="ltr"><![endif]-->
<!--[if (gte IE 9)|(gt IEMobile 7)]><!--><html class="no-js"  lang="en" dir="ltr" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# book: http://ogp.me/ns/book# profile: http://ogp.me/ns/profile# video: http://ogp.me/ns/video# product: http://ogp.me/ns/product# content: http://purl.org/rss/1.0/modules/content/ dc: http://purl.org/dc/terms/ foaf: http://xmlns.com/foaf/0.1/ rdfs: http://www.w3.org/2000/01/rdf-schema# sioc: http://rdfs.org/sioc/ns# sioct: http://rdfs.org/sioc/types# skos: http://www.w3.org/2004/02/skos/core# xsd: http://www.w3.org/2001/XMLSchema#"><!--<![endif]-->

  <head>
<meta charset="utf-8" />
<link rel="shortcut icon" href="https://www.nist.gov/sites/all/themes/nist_style/favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ['tex2jax.js'],
  jax: ['input/TeX','output/HTML-CSS'],
  tex2jax: {
    inlineMath: [ ['$$','$$'], ['\\(','\\)'] ],
    processEscapes: true,
    processClass: 'tex2jax',
    ignoreClass: 'html'
  },
  showProcessingMessages: false,
  messageStyle: 'none'
});
</script>
<meta name="MobileOptimized" content="width">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">

      <!--[if lt IE 9]>
    <script src="https://www.nist.gov/sites/all/themes/zen/js/html5-respond.js"></script>
    <![endif]-->
    <!--[if (gte IE 6)&(lte IE 8)]>
  <script type="text/javascript" src="https://www.nist.gov/sites/all/themes/nist_style/js/selectivizr-min.js"></script>
  <![endif]--><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>fipy.terms package &#8212; FiPy 3.4.3+141.g9c8f5a4b documentation</title>
    <link rel="stylesheet" href="../../_static/ntd2d.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/ntd2d.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="top" title="FiPy 3.4.3+141.g9c8f5a4b documentation" href="../../documentation/contents.html" />
    <link rel="up" title="fipy Package Documentation" href="../../documentation/API.html" />
    <link rel="next" title="fipy.tests package" href="fipy.tests.html" />
    <link rel="prev" title="fipy.steppers package" href="fipy.steppers.html" />
  
 


  <link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
  <script src="https://code.jquery.com/jquery-3.6.2.min.js" type="text/javascript" defer="defer"></script>
  <script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>

  </head>
<!--  <body role="document">-->
  <body class="html not-front not-logged-in no-sidebars page-node page-node- page-node-414011 node-type-software hide-breadcrumb section-services-resources page-panels is-panel" role="document">
      <div id="page" class="mini-header">



    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fipy.tests.html" title="fipy.tests package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fipy.steppers.html" title="fipy.steppers package"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html"><img src="../../_static/fipy.png" alt="FiPy logo"
                 style="vertical-align: middle; margin-top: -1px"/>
        FiPy</a> &gt;</li>

          <li class="nav-item nav-item-1"><a href="../../documentation/API.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fipy</span></code> Package Documentation</a> &gt;</li> 
      </ul>
    </div>

  <div id="main" class="clearfix" role="main" tabindex="-1">
    <div class="main__inner">
      <div class="page-info">
        <a id="main-content"></a>
      </div>

      <div class="document">
        <div class="documentwrapper">

      <div id="content" class="column">
      <div id="block-nist-www-content" class="nist-block">
        <section class="nist-page__content usa-section clearfix">

         

        <div class="grid-container margin-top-4">
        <div class="grid-row grid-gap-6">

  <div class="nist-page__region nist-page__region--content tablet-lg:grid-col-8">
              <div class="body" role="main">
		
  <section id="fipy-terms-package">
<h1>fipy.terms package<a class="headerlink" href="#fipy-terms-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.abstractBinaryTerm">
<span id="fipy-terms-abstractbinaryterm-module"></span><h2>fipy.terms.abstractBinaryTerm module<a class="headerlink" href="#module-fipy.terms.abstractBinaryTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.abstractConvectionTerm">
<span id="fipy-terms-abstractconvectionterm-module"></span><h2>fipy.terms.abstractConvectionTerm module<a class="headerlink" href="#module-fipy.terms.abstractConvectionTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.abstractDiffusionTerm">
<span id="fipy-terms-abstractdiffusionterm-module"></span><h2>fipy.terms.abstractDiffusionTerm module<a class="headerlink" href="#module-fipy.terms.abstractDiffusionTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.abstractUpwindConvectionTerm">
<span id="fipy-terms-abstractupwindconvectionterm-module"></span><h2>fipy.terms.abstractUpwindConvectionTerm module<a class="headerlink" href="#module-fipy.terms.abstractUpwindConvectionTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.advectionTerm">
<span id="fipy-terms-advectionterm-module"></span><h2>fipy.terms.advectionTerm module<a class="headerlink" href="#module-fipy.terms.advectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.advectionTerm.</span></span><span class="sig-name descname"><span class="pre">AdvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm" title="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm</span></code></a></p>
<p>The <cite>AdvectionTerm</cite> object constructs the <cite>b</cite> vector contribution for
the advection term given by</p>
<div class="math notranslate nohighlight">
\[u \abs{\nabla \phi}\]</div>
<p>from the advection equation given by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + u \abs{\nabla \phi} = 0\]</div>
<p>The construction of the gradient magnitude term requires upwinding as in the standard
<cite>FirstOrderAdvectionTerm</cite>. The higher order terms are incorporated as follows.
The formula used here is given by:</p>
<div class="math notranslate nohighlight">
\[u_P \abs{\nabla \phi}_P = \max \left( u_P , 0 \right) \left[  \sum_A \min \left( D_{AP}, 0 \right)^2 \right]^{1/2} +  \min \left( u_P , 0 \right) \left[  \sum_A \max \left( D_{AP}, 0 \right)^2 \right]^{1/2}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[D_{AP} = \frac{ \phi_A - \phi_P } { d_{AP}} - \frac{ d_{AP} } {2} m \left(L_A, L_P \right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}m\left(x, y\right) &amp;= x \qquad \text{if $\abs{x} \le \abs{y} \forall xy \ge 0$} \\
m\left(x, y\right) &amp;= y \qquad \text{if $\abs{x} &gt; \abs{y} \forall xy \ge 0$} \\
m\left(x, y\right) &amp;= 0 \qquad \text{if $xy &lt; 0$}\end{split}\]</div>
<p>also,</p>
<div class="math notranslate nohighlight">
\[\begin{split}L_A &amp;= \frac{\phi_{AA} + \phi_P - 2 \phi_A}{d_{AP}^2} \\
L_P &amp;= \frac{\phi_{A} + \phi_{PP} - 2 \phi_P}{d_{AP}^2}\end{split}\]</div>
<p>Here are some simple test cases for this problem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SparseMatrix</span> <span class="o">=</span> <span class="n">LinearPCGSolver</span><span class="p">()</span><span class="o">.</span><span class="n">_matrixClass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Less trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Even less trivial</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Another trivial test case (more trivial than a trivial test case
standing on a harpsichord singing “trivial test cases are here again”)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Somewhat less trivial test case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>For the above test cases the <cite>AdvectionTerm</cite> gives the
same result as the <cite>AdvectionTerm</cite>. The following test imposes a quadratic
field. The higher order term can resolve this field correctly.</p>
<div class="math notranslate nohighlight">
\[\phi = x^2\]</div>
<p>The returned vector <code class="docutils literal notranslate"><span class="pre">b</span></code> should have the value:</p>
<div class="math notranslate nohighlight">
\[-\abs{\nabla \phi} = -\left|\frac{\partial \phi}{\partial x}\right| = - 2 \abs{x}\]</div>
<p>Build the test case in the following way,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">__AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
</pre></div>
</div>
<p>The first order term is not accurate. The first and last element are ignored because they
don’t have any neighbors for higher order evaluation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
<span class="gp">... </span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The higher order term is spot on.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
<span class="gp">... </span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <cite>AdvectionTerm</cite> will also resolve a circular field with
more accuracy,</p>
<div class="math notranslate nohighlight">
\[\phi = \left( x^2 + y^2 \right)^{1/2}\]</div>
<p>Build the test case in the following way,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">__AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span><span class="p">[(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.123105625618</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The maximum error is large (about 12 %) for the first order advection.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span><span class="p">[(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0201715476598</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The maximum error is 2 % when using a higher order contribution.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.advectionTerm.AdvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.advectionTerm.AdvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.asymmetricConvectionTerm">
<span id="fipy-terms-asymmetricconvectionterm-module"></span><h2>fipy.terms.asymmetricConvectionTerm module<a class="headerlink" href="#module-fipy.terms.asymmetricConvectionTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.binaryTerm">
<span id="fipy-terms-binaryterm-module"></span><h2>fipy.terms.binaryTerm module<a class="headerlink" href="#module-fipy.terms.binaryTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.cellTerm">
<span id="fipy-terms-cellterm-module"></span><h2>fipy.terms.cellTerm module<a class="headerlink" href="#module-fipy.terms.cellTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.cellTerm.</span></span><span class="sig-name descname"><span class="pre">CellTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_NonDiffusionTerm</span></code></p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>This class is abstract. Always create one of its subclasses.</p>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.cellTerm.CellTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.cellTerm.CellTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.centralDiffConvectionTerm">
<span id="fipy-terms-centraldiffconvectionterm-module"></span><h2>fipy.terms.centralDiffConvectionTerm module<a class="headerlink" href="#module-fipy.terms.centralDiffConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.centralDiffConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">CentralDifferenceConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractConvectionTerm</span></code></p>
<p>This <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the central differencing scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.coupledBinaryTerm">
<span id="fipy-terms-coupledbinaryterm-module"></span><h2>fipy.terms.coupledBinaryTerm module<a class="headerlink" href="#module-fipy.terms.coupledBinaryTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.diffusionTerm">
<span id="fipy-terms-diffusionterm-module"></span><h2>fipy.terms.diffusionTerm module<a class="headerlink" href="#module-fipy.terms.diffusionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.diffusionTerm.</span></span><span class="sig-name descname"><span class="pre">DiffusionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection" title="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection</span></code></a></p>
<p>This term represents a higher order diffusion term. The order of the term is determined
by the number of <cite>coeffs</cite>, such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DiffusionTerm</span><span class="p">(</span><span class="n">D1</span><span class="p">)</span>
</pre></div>
</div>
<p>represents a typical 2nd-order diffusion term of the form</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left(D_1 \nabla \phi\right)\]</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DiffusionTerm</span><span class="p">((</span><span class="n">D1</span><span class="p">,</span><span class="n">D2</span><span class="p">))</span>
</pre></div>
</div>
<p>represents a 4th-order Cahn-Hilliard term of the form</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot \left\{ D_1 \nabla \left[ \nabla\cdot\left( D_2 \nabla \phi\right) \right] \right\}\]</div>
<p>and so on.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.diffusionTerm.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.diffusionTerm.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermNoCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTerm.DiffusionTermNoCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.diffusionTermCorrection">
<span id="fipy-terms-diffusiontermcorrection-module"></span><h2>fipy.terms.diffusionTermCorrection module<a class="headerlink" href="#module-fipy.terms.diffusionTermCorrection" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.diffusionTermCorrection.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.diffusionTermNoCorrection">
<span id="fipy-terms-diffusiontermnocorrection-module"></span><h2>fipy.terms.diffusionTermNoCorrection module<a class="headerlink" href="#module-fipy.terms.diffusionTermNoCorrection" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.diffusionTermNoCorrection.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermNoCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.explicitDiffusionTerm">
<span id="fipy-terms-explicitdiffusionterm-module"></span><h2>fipy.terms.explicitDiffusionTerm module<a class="headerlink" href="#module-fipy.terms.explicitDiffusionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.explicitDiffusionTerm.</span></span><span class="sig-name descname"><span class="pre">ExplicitDiffusionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>The discretization for the <cite>ExplicitDiffusionTerm</cite> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\Gamma\nabla\phi) dV \simeq \sum_f \Gamma_f
\frac{\phi_A^\text{old}-\phi_P^\text{old}}{d_{AP}} A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_A^\text{old}\)</span> and <span class="math notranslate nohighlight">\(\phi_P^\text{old}\)</span> are the old values of the
variable. The term is added to the RHS vector and makes no contribution to
the solution matrix.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.explicitSourceTerm">
<span id="fipy-terms-explicitsourceterm-module"></span><h2>fipy.terms.explicitSourceTerm module<a class="headerlink" href="#module-fipy.terms.explicitSourceTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.explicitUpwindConvectionTerm">
<span id="fipy-terms-explicitupwindconvectionterm-module"></span><h2>fipy.terms.explicitUpwindConvectionTerm module<a class="headerlink" href="#module-fipy.terms.explicitUpwindConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.explicitUpwindConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">ExplicitUpwindConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractUpwindConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P^\text{old} +(1-\alpha_f)\phi_A^\text{old}\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the upwind scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.exponentialConvectionTerm">
<span id="fipy-terms-exponentialconvectionterm-module"></span><h2>fipy.terms.exponentialConvectionTerm module<a class="headerlink" href="#module-fipy.terms.exponentialConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.exponentialConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">ExponentialConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the exponential scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.faceTerm">
<span id="fipy-terms-faceterm-module"></span><h2>fipy.terms.faceTerm module<a class="headerlink" href="#module-fipy.terms.faceTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.faceTerm.</span></span><span class="sig-name descname"><span class="pre">FaceTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_NonDiffusionTerm</span></code></p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>This class is abstract. Always create one of its subclasses.</p>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.faceTerm.FaceTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.faceTerm.FaceTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.firstOrderAdvectionTerm">
<span id="fipy-terms-firstorderadvectionterm-module"></span><h2>fipy.terms.firstOrderAdvectionTerm module<a class="headerlink" href="#module-fipy.terms.firstOrderAdvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.firstOrderAdvectionTerm.</span></span><span class="sig-name descname"><span class="pre">FirstOrderAdvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_NonDiffusionTerm</span></code></p>
<p>The <cite>FirstOrderAdvectionTerm</cite> object constructs the b vector contribution
for the advection term given by</p>
<div class="math notranslate nohighlight">
\[u \abs{\nabla \phi}\]</div>
<p>from the advection equation given by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + u \abs{\nabla \phi} = 0\]</div>
<p>The construction of the gradient magnitude term requires upwinding.
The formula used here is given by:</p>
<div class="math notranslate nohighlight">
\[u_P \abs{\nabla \phi}_P = \max \left( u_P , 0 \right) \left[  \sum_A \min \left( \frac{ \phi_A - \phi_P } { d_{AP}}, 0 \right)^2 \right]^{1/2} +  \min \left( u_P , 0 \right) \left[  \sum_A \max \left( \frac{ \phi_A - \phi_P } { d_{AP}}, 0 \right)^2 \right]^{1/2}\]</div>
<p>Here are some simple test cases for this problem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SparseMatrix</span> <span class="o">=</span> <span class="n">LinearLUSolver</span><span class="p">()</span><span class="o">.</span><span class="n">_matrixClass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
</pre></div>
</div>
<p>Trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Less trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Even less trivial</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Another trivial test case (more trivial than a trivial test case
standing on a harpsichord singing “trivial test cases are here again”)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Somewhat less trivial test case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.hybridConvectionTerm">
<span id="fipy-terms-hybridconvectionterm-module"></span><h2>fipy.terms.hybridConvectionTerm module<a class="headerlink" href="#module-fipy.terms.hybridConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.hybridConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">HybridConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the hybrid scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.hybridConvectionTerm.HybridConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.implicitDiffusionTerm">
<span id="fipy-terms-implicitdiffusionterm-module"></span><h2>fipy.terms.implicitDiffusionTerm module<a class="headerlink" href="#module-fipy.terms.implicitDiffusionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.implicitDiffusionTerm.ImplicitDiffusionTerm">
<span class="sig-prename descclassname"><span class="pre">fipy.terms.implicitDiffusionTerm.</span></span><span class="sig-name descname"><span class="pre">ImplicitDiffusionTerm</span></span><a class="headerlink" href="#fipy.terms.implicitDiffusionTerm.ImplicitDiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm" title="fipy.terms.diffusionTerm.DiffusionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionTerm</span></code></a></p>
</dd></dl>

</section>
<section id="module-fipy.terms.implicitSourceTerm">
<span id="fipy-terms-implicitsourceterm-module"></span><h2>fipy.terms.implicitSourceTerm module<a class="headerlink" href="#module-fipy.terms.implicitSourceTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.implicitSourceTerm.</span></span><span class="sig-name descname"><span class="pre">ImplicitSourceTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm" title="fipy.terms.sourceTerm.SourceTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">SourceTerm</span></code></a></p>
<p>The <cite>ImplicitSourceTerm</cite> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \phi S \,dV \simeq \phi_P S_P V_P\]</div>
<p>where <span class="math notranslate nohighlight">\(S\)</span> is the <cite>coeff</cite> value.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.implicitSourceTerm.ImplicitSourceTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.nonDiffusionTerm">
<span id="fipy-terms-nondiffusionterm-module"></span><h2>fipy.terms.nonDiffusionTerm module<a class="headerlink" href="#module-fipy.terms.nonDiffusionTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.powerLawConvectionTerm">
<span id="fipy-terms-powerlawconvectionterm-module"></span><h2>fipy.terms.powerLawConvectionTerm module<a class="headerlink" href="#module-fipy.terms.powerLawConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.powerLawConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">PowerLawConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the power law scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.residualTerm">
<span id="fipy-terms-residualterm-module"></span><h2>fipy.terms.residualTerm module<a class="headerlink" href="#module-fipy.terms.residualTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.residualTerm.</span></span><span class="sig-name descname"><span class="pre">ResidualTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_ExplicitSourceTerm</span></code></p>
<p>The <cite>ResidualTerm</cite> is a special form of explicit <cite>SourceTerm</cite> that adds the
residual of one equation to another equation. Useful for Newton’s method.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.residualTerm.ResidualTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.residualTerm.ResidualTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.sourceTerm">
<span id="fipy-terms-sourceterm-module"></span><h2>fipy.terms.sourceTerm module<a class="headerlink" href="#module-fipy.terms.sourceTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.sourceTerm.</span></span><span class="sig-name descname"><span class="pre">SourceTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.cellTerm.CellTerm" title="fipy.terms.cellTerm.CellTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">CellTerm</span></code></a></p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>This class is abstract. Always create one of its subclasses.</p>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.sourceTerm.SourceTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.sourceTerm.SourceTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.term">
<span id="fipy-terms-term-module"></span><h2>fipy.terms.term module<a class="headerlink" href="#module-fipy.terms.term" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.term.Term">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.term.</span></span><span class="sig-name descname"><span class="pre">Term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>This class is abstract. Always create one of its subclasses.</p>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.term.Term.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.term.Term.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.term.Term.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.term.Term.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.term.Term.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.term.Term.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.test">
<span id="fipy-terms-test-module"></span><h2>fipy.terms.test module<a class="headerlink" href="#module-fipy.terms.test" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.transientTerm">
<span id="fipy-terms-transientterm-module"></span><h2>fipy.terms.transientTerm module<a class="headerlink" href="#module-fipy.terms.transientTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.transientTerm.</span></span><span class="sig-name descname"><span class="pre">TransientTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.cellTerm.CellTerm" title="fipy.terms.cellTerm.CellTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">CellTerm</span></code></a></p>
<p>The <cite>TransientTerm</cite> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \frac{\partial (\rho \phi)}{\partial t} dV \simeq
\frac{(\rho_{P} \phi_{P} - \rho_{P}^\text{old} \phi_P^\text{old}) V_P}{\Delta t}\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the <cite>coeff</cite> value.</p>
<p>The following test case verifies that variable coefficients and
old coefficient values work correctly. We will solve the
following equation</p>
<div class="math notranslate nohighlight">
\[\frac{ \partial \phi^2 } { \partial t } = k.\]</div>
<p>The analytic solution is given by</p>
<div class="math notranslate nohighlight">
\[\phi = \sqrt{ \phi_0^2 + k t },\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_0\)</span> is the initial value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phi0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relaxationFactor</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">steps</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sweeps</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">hasOld</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.terms.transientTerm</span> <span class="kn">import</span> <span class="n">TransientTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.terms.implicitSourceTerm</span> <span class="kn">import</span> <span class="n">ImplicitSourceTerm</span>
</pre></div>
</div>
<p>Relaxation, given by <cite>relaxationFactor</cite>, is required for a
converged solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">TransientTerm</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="n">ImplicitSourceTerm</span><span class="p">(</span><span class="o">-</span><span class="n">relaxationFactor</span><span class="p">)</span> \
<span class="gp">... </span>                           <span class="o">+</span> <span class="n">var</span> <span class="o">*</span> <span class="n">relaxationFactor</span> <span class="o">+</span> <span class="n">k</span>
</pre></div>
</div>
<p>A number of sweeps at each time step are required to let the
relaxation take effect.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">var</span><span class="o">.</span><span class="n">updateOld</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">sweep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweeps</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">eq</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Compare the final result with the analytical solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.tools</span> <span class="kn">import</span> <span class="n">numerix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">phi0</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.transientTerm.TransientTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.transientTerm.TransientTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.unaryTerm">
<span id="fipy-terms-unaryterm-module"></span><h2>fipy.terms.unaryTerm module<a class="headerlink" href="#module-fipy.terms.unaryTerm" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-fipy.terms.upwindConvectionTerm">
<span id="fipy-terms-upwindconvectionterm-module"></span><h2>fipy.terms.upwindConvectionTerm module<a class="headerlink" href="#module-fipy.terms.upwindConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.upwindConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">UpwindConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractUpwindConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the upwind convection scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms.vanLeerConvectionTerm">
<span id="fipy-terms-vanleerconvectionterm-module"></span><h2>fipy.terms.vanLeerConvectionTerm module<a class="headerlink" href="#module-fipy.terms.vanLeerConvectionTerm" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.vanLeerConvectionTerm.</span></span><span class="sig-name descname"><span class="pre">VanLeerConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm" title="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm</span></code></a></p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-fipy.terms">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-fipy.terms" title="Permalink to this heading">¶</a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">AbstractBaseClassError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">&quot;can't</span> <span class="pre">instantiate</span> <span class="pre">abstract</span> <span class="pre">base</span> <span class="pre">class&quot;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AbstractBaseClassError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AbstractBaseClassError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">AdvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm" title="fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm</span></code></a></p>
<p>The <cite>AdvectionTerm</cite> object constructs the <cite>b</cite> vector contribution for
the advection term given by</p>
<div class="math notranslate nohighlight">
\[u \abs{\nabla \phi}\]</div>
<p>from the advection equation given by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + u \abs{\nabla \phi} = 0\]</div>
<p>The construction of the gradient magnitude term requires upwinding as in the standard
<cite>FirstOrderAdvectionTerm</cite>. The higher order terms are incorporated as follows.
The formula used here is given by:</p>
<div class="math notranslate nohighlight">
\[u_P \abs{\nabla \phi}_P = \max \left( u_P , 0 \right) \left[  \sum_A \min \left( D_{AP}, 0 \right)^2 \right]^{1/2} +  \min \left( u_P , 0 \right) \left[  \sum_A \max \left( D_{AP}, 0 \right)^2 \right]^{1/2}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[D_{AP} = \frac{ \phi_A - \phi_P } { d_{AP}} - \frac{ d_{AP} } {2} m \left(L_A, L_P \right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}m\left(x, y\right) &amp;= x \qquad \text{if $\abs{x} \le \abs{y} \forall xy \ge 0$} \\
m\left(x, y\right) &amp;= y \qquad \text{if $\abs{x} &gt; \abs{y} \forall xy \ge 0$} \\
m\left(x, y\right) &amp;= 0 \qquad \text{if $xy &lt; 0$}\end{split}\]</div>
<p>also,</p>
<div class="math notranslate nohighlight">
\[\begin{split}L_A &amp;= \frac{\phi_{AA} + \phi_P - 2 \phi_A}{d_{AP}^2} \\
L_P &amp;= \frac{\phi_{A} + \phi_{PP} - 2 \phi_P}{d_{AP}^2}\end{split}\]</div>
<p>Here are some simple test cases for this problem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SparseMatrix</span> <span class="o">=</span> <span class="n">LinearPCGSolver</span><span class="p">()</span><span class="o">.</span><span class="n">_matrixClass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Less trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Even less trivial</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Another trivial test case (more trivial than a trivial test case
standing on a harpsichord singing “trivial test cases are here again”)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Somewhat less trivial test case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>For the above test cases the <cite>AdvectionTerm</cite> gives the
same result as the <cite>AdvectionTerm</cite>. The following test imposes a quadratic
field. The higher order term can resolve this field correctly.</p>
<div class="math notranslate nohighlight">
\[\phi = x^2\]</div>
<p>The returned vector <code class="docutils literal notranslate"><span class="pre">b</span></code> should have the value:</p>
<div class="math notranslate nohighlight">
\[-\abs{\nabla \phi} = -\left|\frac{\partial \phi}{\partial x}\right| = - 2 \abs{x}\]</div>
<p>Build the test case in the following way,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">__AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
</pre></div>
</div>
<p>The first order term is not accurate. The first and last element are ignored because they
don’t have any neighbors for higher order evaluation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
<span class="gp">... </span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The higher order term is spot on.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
<span class="gp">... </span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span><span class="o">.</span><span class="n">globalValue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <cite>AdvectionTerm</cite> will also resolve a circular field with
more accuracy,</p>
<div class="math notranslate nohighlight">
\[\phi = \left( x^2 + y^2 \right)^{1/2}\]</div>
<p>Build the test case in the following way,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cellCenters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">__AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span><span class="p">[(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.123105625618</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The maximum error is large (about 12 %) for the first order advection.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">AdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span><span class="p">[(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0201715476598</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The maximum error is 2 % when using a higher order contribution.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.AdvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.AdvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.AdvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.AdvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">CentralDifferenceConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractConvectionTerm</span></code></p>
<p>This <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the central differencing scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.CentralDifferenceConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.CentralDifferenceConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ConvectionTerm">
<span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ConvectionTerm</span></span><a class="headerlink" href="#fipy.terms.ConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm" title="fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerLawConvectionTerm</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">DiffusionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection" title="fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection</span></code></a></p>
<p>This term represents a higher order diffusion term. The order of the term is determined
by the number of <cite>coeffs</cite>, such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DiffusionTerm</span><span class="p">(</span><span class="n">D1</span><span class="p">)</span>
</pre></div>
</div>
<p>represents a typical 2nd-order diffusion term of the form</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left(D_1 \nabla \phi\right)\]</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DiffusionTerm</span><span class="p">((</span><span class="n">D1</span><span class="p">,</span><span class="n">D2</span><span class="p">))</span>
</pre></div>
</div>
<p>represents a 4th-order Cahn-Hilliard term of the form</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot \left\{ D_1 \nabla \left[ \nabla\cdot\left( D_2 \nabla \phi\right) \right] \right\}\]</div>
<p>and so on.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.DiffusionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.DiffusionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">DiffusionTermNoCorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.DiffusionTermNoCorrection.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.DiffusionTermNoCorrection.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ExplicitDiffusionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractDiffusionTerm</span></code></p>
<p>The discretization for the <cite>ExplicitDiffusionTerm</cite> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\Gamma\nabla\phi) dV \simeq \sum_f \Gamma_f
\frac{\phi_A^\text{old}-\phi_P^\text{old}}{d_{AP}} A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_A^\text{old}\)</span> and <span class="math notranslate nohighlight">\(\phi_P^\text{old}\)</span> are the old values of the
variable. The term is added to the RHS vector and makes no contribution to
the solution matrix.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitDiffusionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitDiffusionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ExplicitUpwindConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractUpwindConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P^\text{old} +(1-\alpha_f)\phi_A^\text{old}\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the upwind scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitUpwindConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitUpwindConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ExplicitVariableError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Terms</span> <span class="pre">with</span> <span class="pre">explicit</span> <span class="pre">Variables</span> <span class="pre">cannot</span> <span class="pre">mix</span> <span class="pre">with</span> <span class="pre">Terms</span> <span class="pre">with</span> <span class="pre">implicit</span> <span class="pre">Variables.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExplicitVariableError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExplicitVariableError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ExponentialConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the exponential scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ExponentialConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ExponentialConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">FirstOrderAdvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_NonDiffusionTerm</span></code></p>
<p>The <cite>FirstOrderAdvectionTerm</cite> object constructs the b vector contribution
for the advection term given by</p>
<div class="math notranslate nohighlight">
\[u \abs{\nabla \phi}\]</div>
<p>from the advection equation given by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + u \abs{\nabla \phi} = 0\]</div>
<p>The construction of the gradient magnitude term requires upwinding.
The formula used here is given by:</p>
<div class="math notranslate nohighlight">
\[u_P \abs{\nabla \phi}_P = \max \left( u_P , 0 \right) \left[  \sum_A \min \left( \frac{ \phi_A - \phi_P } { d_{AP}}, 0 \right)^2 \right]^{1/2} +  \min \left( u_P , 0 \right) \left[  \sum_A \max \left( \frac{ \phi_A - \phi_P } { d_{AP}}, 0 \right)^2 \right]^{1/2}\]</div>
<p>Here are some simple test cases for this problem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SparseMatrix</span> <span class="o">=</span> <span class="n">LinearLUSolver</span><span class="p">()</span><span class="o">.</span><span class="n">_matrixClass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
</pre></div>
</div>
<p>Trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Less trivial test:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Even less trivial</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Another trivial test case (more trivial than a trivial test case
standing on a harpsichord singing “trivial test cases are here again”)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Somewhat less trivial test case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">FirstOrderAdvectionTerm</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span><span class="o">.</span><span class="n">_buildMatrix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="n">vel</span> <span class="o">*</span> <span class="n">numerix</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span> 
<span class="go">True</span>
</pre></div>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.FirstOrderAdvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.FirstOrderAdvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">HybridConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the hybrid scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.HybridConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.HybridConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.ImplicitDiffusionTerm">
<span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ImplicitDiffusionTerm</span></span><a class="headerlink" href="#fipy.terms.ImplicitDiffusionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm" title="fipy.terms.diffusionTerm.DiffusionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionTerm</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ImplicitSourceTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm" title="fipy.terms.sourceTerm.SourceTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">SourceTerm</span></code></a></p>
<p>The <cite>ImplicitSourceTerm</cite> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \phi S \,dV \simeq \phi_P S_P V_P\]</div>
<p>where <span class="math notranslate nohighlight">\(S\)</span> is the <cite>coeff</cite> value.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ImplicitSourceTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ImplicitSourceTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">IncorrectSolutionVariable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'The</span> <span class="pre">solution</span> <span class="pre">variable</span> <span class="pre">is</span> <span class="pre">incorrect.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.IncorrectSolutionVariable.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.IncorrectSolutionVariable.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">PowerLawConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AsymmetricConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the power law scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.PowerLawConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.PowerLawConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">ResidualTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_ExplicitSourceTerm</span></code></p>
<p>The <cite>ResidualTerm</cite> is a special form of explicit <cite>SourceTerm</cite> that adds the
residual of one equation to another equation. Useful for Newton’s method.</p>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.ResidualTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.ResidualTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.ResidualTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.ResidualTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">SolutionVariableNumberError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Different</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">solution</span> <span class="pre">variables</span> <span class="pre">and</span> <span class="pre">equations.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableNumberError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableNumberError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">SolutionVariableRequiredError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'The</span> <span class="pre">solution</span> <span class="pre">variable</span> <span class="pre">needs</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">specified.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.SolutionVariableRequiredError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.SolutionVariableRequiredError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">TermMultiplyError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Must</span> <span class="pre">multiply</span> <span class="pre">terms</span> <span class="pre">by</span> <span class="pre">int</span> <span class="pre">or</span> <span class="pre">float.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.TermMultiplyError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.TermMultiplyError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TermMultiplyError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TermMultiplyError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">TransientTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.cellTerm.CellTerm" title="fipy.terms.cellTerm.CellTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">CellTerm</span></code></a></p>
<p>The <cite>TransientTerm</cite> represents</p>
<div class="math notranslate nohighlight">
\[\int_V \frac{\partial (\rho \phi)}{\partial t} dV \simeq
\frac{(\rho_{P} \phi_{P} - \rho_{P}^\text{old} \phi_P^\text{old}) V_P}{\Delta t}\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the <cite>coeff</cite> value.</p>
<p>The following test case verifies that variable coefficients and
old coefficient values work correctly. We will solve the
following equation</p>
<div class="math notranslate nohighlight">
\[\frac{ \partial \phi^2 } { \partial t } = k.\]</div>
<p>The analytic solution is given by</p>
<div class="math notranslate nohighlight">
\[\phi = \sqrt{ \phi_0^2 + k t },\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_0\)</span> is the initial value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phi0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relaxationFactor</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">steps</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sweeps</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.meshes</span> <span class="kn">import</span> <span class="n">Grid1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.variables.cellVariable</span> <span class="kn">import</span> <span class="n">CellVariable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">hasOld</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.terms.transientTerm</span> <span class="kn">import</span> <span class="n">TransientTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.terms.implicitSourceTerm</span> <span class="kn">import</span> <span class="n">ImplicitSourceTerm</span>
</pre></div>
</div>
<p>Relaxation, given by <cite>relaxationFactor</cite>, is required for a
converged solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">TransientTerm</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="n">ImplicitSourceTerm</span><span class="p">(</span><span class="o">-</span><span class="n">relaxationFactor</span><span class="p">)</span> \
<span class="gp">... </span>                           <span class="o">+</span> <span class="n">var</span> <span class="o">*</span> <span class="n">relaxationFactor</span> <span class="o">+</span> <span class="n">k</span>
</pre></div>
</div>
<p>A number of sweeps at each time step are required to let the
relaxation take effect.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">var</span><span class="o">.</span><span class="n">updateOld</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">sweep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sweeps</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">eq</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Compare the final result with the analytical solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.tools</span> <span class="kn">import</span> <span class="n">numerix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">phi0</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Create a <cite>Term</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a><em> or </em><a class="reference internal" href="fipy.variables.html#fipy.variables.faceVariable.FaceVariable" title="fipy.variables.faceVariable.FaceVariable"><em>FaceVariable</em></a>) – Coefficient for the term.  <cite>FaceVariable</cite> objects are only
acceptable for diffusion or convection terms.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.TransientTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.TransientTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.TransientTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.TransientTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">UpwindConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_AbstractUpwindConvectionTerm</span></code></p>
<p>The discretization for this <a class="reference internal" href="#fipy.terms.term.Term" title="fipy.terms.term.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">Term</span></code></a> is given by</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot (\vec{u} \phi)\,dV \simeq \sum_{f} (\vec{n}
\cdot \vec{u})_f \phi_f A_f\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_f=\alpha_f \phi_P +(1-\alpha_f)\phi_A\)</span> and
<span class="math notranslate nohighlight">\(\alpha_f\)</span> is calculated using the upwind convection scheme.
For further details see <a class="reference internal" href="../../documentation/numerical/scheme.html#sec-numericalschemes"><span class="std std-ref">Numerical Schemes</span></a>.</p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.UpwindConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.UpwindConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">VanLeerConvectionTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm" title="fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm</span></code></a></p>
<p>Create a <cite>_AbstractConvectionTerm</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">cv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">fv</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vcv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">vfv</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.]]), mesh=UniformGrid1D(dx=1.0, nx=2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">__ConvectionTerm(coeff=(1,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">())</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TransientTermError</span>: <span class="n">The equation requires a TransientTerm with explicit convection.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">VectorCoeffError</span>: <span class="n">The coefficient must be a vector value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Grid2D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcv2</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfv2</span> <span class="o">=</span> <span class="n">FaceVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vcv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=_ArithmeticCellToFaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__ConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="n">vfv2</span><span class="p">)</span>
<span class="go">__ConvectionTerm(coeff=FaceVariable(value=array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]), mesh=UniformGrid2D(dx=1.0, nx=2, dy=1.0, ny=1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">TransientTerm</span><span class="p">()</span> <span class="o">-</span> <span class="n">ExplicitUpwindConvectionTerm</span><span class="p">(</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">cv2</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeff</strong> (The <cite>Term</cite>’s coefficient value.) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.RHSvector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RHSvector</span></span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.RHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RHS vector calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheRHSvector()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__and__">
<span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__and__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__div__">
<span class="sig-name descname"><span class="pre">__div__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__div__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate a <cite>Term</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=-1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__pos__">
<span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__pos__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__radd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__rand__">
<span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__rand__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>The representation of a <cite>Term</cite> object is given by,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">__UnaryTerm</span><span class="p">(</span><span class="mf">123.456</span><span class="p">))</span>
<span class="go">__UnaryTerm(coeff=123.456)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.</span> <span class="o">*</span> <span class="n">__NonDiffusionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">__NonDiffusionTerm(coeff=1.0)</span>
</pre></div>
</div>
<p>Test for ticket:291.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="n">PowerLawConvectionTerm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PowerLawConvectionTerm</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="mf">1.0</span>
<span class="go">PowerLawConvectionTerm(coeff=array([[ 1.],</span>
<span class="go">       [ 0.]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__sub__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.__truediv__">
<span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.__truediv__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.cacheMatrix">
<span class="sig-name descname"><span class="pre">cacheMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.cacheMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their matrix so
that <cite>matrix</cite> can return the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.cacheRHSvector">
<span class="sig-name descname"><span class="pre">cacheRHSvector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.cacheRHSvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs <cite>solve()</cite> and <cite>sweep()</cite> to cache their right hand side
vector so that <cite>getRHSvector()</cite> can return it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.getDefaultSolver">
<span class="sig-name descname"><span class="pre">getDefaultSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.getDefaultSolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.justErrorVector">
<span class="sig-name descname"><span class="pre">justErrorVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.justErrorVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the error as well as
applying under-relaxation.</p>
<p><cite>justErrorVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy.solvers</span> <span class="kn">import</span> <span class="n">DummySolver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justErrorVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">DummySolver</span><span class="p">()))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>error</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{e}=\mathsf{L}\vec{x}_\text{old} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.justResidualVector">
<span class="sig-name descname"><span class="pre">justResidualVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.justResidualVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<p><cite>justResidualVector</cite> returns the overlapping local value in parallel (not the non-overlapping value).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Grid1D</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">CellVariable</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">numerix</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">DiffusionTerm</span><span class="p">()</span><span class="o">.</span><span class="n">justResidualVector</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">numberOfCells</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix calculated in <cite>solve()</cite> or <cite>sweep()</cite>. The
<cite>cacheMatrix()</cite> method should be called before <cite>solve()</cite> or
<cite>sweep()</cite> to cache the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.residualVectorAndNorm">
<span class="sig-name descname"><span class="pre">residualVectorAndNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.residualVectorAndNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the <cite>Term</cite>’s linear system once.</p>
<p>This method also recalculates and returns the residual as well as
applying under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>residual</strong> (<em>~fipy.variables.cellVariable.CellVariable</em>) – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p></li>
<li><p><strong>norm</strong> (<em>float</em>) – The L2 norm of <cite>residual</cite>, <span class="math notranslate nohighlight">\(\|\vec{r}\|_2\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
does not return the residual. It should be used when the
residual is not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VanLeerConvectionTerm.sweep">
<span class="sig-name descname"><span class="pre">sweep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryConditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underRelaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residualFn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheResidual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cacheError</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VanLeerConvectionTerm.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds and solves the <cite>Term</cite>’s linear system once. This method
also recalculates and returns the residual as well as applying
under-relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a>) – <cite>Variable</cite> to be solved for.  Provides the initial condition,
the old value and holds the solution on completion.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="fipy.solvers.html#fipy.solvers.solver.Solver" title="fipy.solvers.solver.Solver"><em>Solver</em></a>) – Iterative solver to be used to solve the linear system of
equations.  The default sovler depends on the solver package
selected.</p></li>
<li><p><strong>boundaryConditions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="fipy.boundaryConditions.html#fipy.boundaryConditions.boundaryCondition.BoundaryCondition" title="fipy.boundaryConditions.boundaryCondition.BoundaryCondition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundaryCondition</span></code></a>) – </p></li>
<li><p><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Timestep size.</p></li>
<li><p><strong>underRelaxation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Usually a value between <cite>0</cite> and <cite>1</cite> or <cite>None</cite> in the case of no
under-relaxation</p></li>
<li><p><strong>residualFn</strong> (<em>function</em>) – Takes <cite>var</cite>, <cite>matrix</cite>, and <cite>RHSvector</cite> arguments, used to
customize the residual calculation.</p></li>
<li><p><strong>cacheResidual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, calculate and store the residual vector
<span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span> in the
<cite>residualVector</cite> member of <cite>Term</cite></p></li>
<li><p><strong>cacheError</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If <cite>True</cite>, use the residual vector <span class="math notranslate nohighlight">\(\vec{r}\)</span> to solve
<span class="math notranslate nohighlight">\(\mathsf{L}\vec{e}=\vec{r}\)</span> for the error vector
<span class="math notranslate nohighlight">\(\vec{e}\)</span> and store it in the <cite>errorVector</cite> member of
<cite>Term</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>residual</strong> – The residual vector <span class="math notranslate nohighlight">\(\vec{r}=\mathsf{L}\vec{x} - \vec{b}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="fipy.variables.html#fipy.variables.cellVariable.CellVariable" title="fipy.variables.cellVariable.CellVariable"><em>CellVariable</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fipy.terms.</span></span><span class="sig-name descname"><span class="pre">VectorCoeffError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'The</span> <span class="pre">coefficient</span> <span class="pre">must</span> <span class="pre">be</span> <span class="pre">a</span> <span class="pre">vector</span> <span class="pre">value.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__cause__">
<span class="sig-name descname"><span class="pre">__cause__</span></span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__context__">
<span class="sig-name descname"><span class="pre">__context__</span></span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__setstate__">
<span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__suppress_context__">
<span class="sig-name descname"><span class="pre">__suppress_context__</span></span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span><a class="headerlink" href="#fipy.terms.VectorCoeffError.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#fipy.terms.VectorCoeffError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fipy.terms.VectorCoeffError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fipy.terms.VectorCoeffError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

</section>
</section>


                <div class='last-updated'>
                Last updated on May 25, 2023.
                Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.
                </div>
              </div>
  </div>  
  <aside class="nist-page__region nist-page__region--sidebar-second tablet-lg:grid-col-4">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

            <p class="logo"><a href="../../documentation/contents.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<strong>FiPy: A Finite Volume PDE Solver Using Python</strong><br />
Version 3.4.3+141.g9c8f5a4b

  <div class="sphinxsidebarsection">
  <h3><a href="../../documentation/contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">fipy.terms package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-fipy.terms.abstractBinaryTerm">fipy.terms.abstractBinaryTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.abstractConvectionTerm">fipy.terms.abstractConvectionTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.abstractDiffusionTerm">fipy.terms.abstractDiffusionTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.abstractUpwindConvectionTerm">fipy.terms.abstractUpwindConvectionTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.advectionTerm">fipy.terms.advectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.advectionTerm.AdvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.asymmetricConvectionTerm">fipy.terms.asymmetricConvectionTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.binaryTerm">fipy.terms.binaryTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.cellTerm">fipy.terms.cellTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm"><code class="docutils literal notranslate"><span class="pre">CellTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">CellTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__add__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__and__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__div__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">CellTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">CellTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">CellTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.copy"><code class="docutils literal notranslate"><span class="pre">CellTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">CellTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">CellTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">CellTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.matrix"><code class="docutils literal notranslate"><span class="pre">CellTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">CellTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.solve"><code class="docutils literal notranslate"><span class="pre">CellTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.cellTerm.CellTerm.sweep"><code class="docutils literal notranslate"><span class="pre">CellTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.centralDiffConvectionTerm">fipy.terms.centralDiffConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.centralDiffConvectionTerm.CentralDifferenceConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.coupledBinaryTerm">fipy.terms.coupledBinaryTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.diffusionTerm">fipy.terms.diffusionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTerm.DiffusionTermNoCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.diffusionTermCorrection">fipy.terms.diffusionTermCorrection module</a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermCorrection.DiffusionTermCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.diffusionTermNoCorrection">fipy.terms.diffusionTermNoCorrection module</a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.diffusionTermNoCorrection.DiffusionTermNoCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.explicitDiffusionTerm">fipy.terms.explicitDiffusionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitDiffusionTerm.ExplicitDiffusionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.explicitSourceTerm">fipy.terms.explicitSourceTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.explicitUpwindConvectionTerm">fipy.terms.explicitUpwindConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.explicitUpwindConvectionTerm.ExplicitUpwindConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.exponentialConvectionTerm">fipy.terms.exponentialConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.exponentialConvectionTerm.ExponentialConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.faceTerm">fipy.terms.faceTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm"><code class="docutils literal notranslate"><span class="pre">FaceTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">FaceTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__add__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__and__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__div__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">FaceTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">FaceTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">FaceTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.copy"><code class="docutils literal notranslate"><span class="pre">FaceTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">FaceTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">FaceTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">FaceTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.matrix"><code class="docutils literal notranslate"><span class="pre">FaceTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">FaceTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.solve"><code class="docutils literal notranslate"><span class="pre">FaceTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.faceTerm.FaceTerm.sweep"><code class="docutils literal notranslate"><span class="pre">FaceTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.firstOrderAdvectionTerm">fipy.terms.firstOrderAdvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.firstOrderAdvectionTerm.FirstOrderAdvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.hybridConvectionTerm">fipy.terms.hybridConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.hybridConvectionTerm.HybridConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.implicitDiffusionTerm">fipy.terms.implicitDiffusionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.implicitDiffusionTerm.ImplicitDiffusionTerm"><code class="docutils literal notranslate"><span class="pre">ImplicitDiffusionTerm</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.implicitSourceTerm">fipy.terms.implicitSourceTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.copy"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.solve"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.implicitSourceTerm.ImplicitSourceTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.nonDiffusionTerm">fipy.terms.nonDiffusionTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.powerLawConvectionTerm">fipy.terms.powerLawConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.powerLawConvectionTerm.PowerLawConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.residualTerm">fipy.terms.residualTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm"><code class="docutils literal notranslate"><span class="pre">ResidualTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.copy"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.solve"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.residualTerm.ResidualTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.sourceTerm">fipy.terms.sourceTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm"><code class="docutils literal notranslate"><span class="pre">SourceTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">SourceTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__add__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__and__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__div__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">SourceTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">SourceTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">SourceTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.copy"><code class="docutils literal notranslate"><span class="pre">SourceTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">SourceTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">SourceTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">SourceTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.matrix"><code class="docutils literal notranslate"><span class="pre">SourceTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">SourceTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.solve"><code class="docutils literal notranslate"><span class="pre">SourceTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.sourceTerm.SourceTerm.sweep"><code class="docutils literal notranslate"><span class="pre">SourceTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.term">fipy.terms.term module</a><ul>
<li><a class="reference internal" href="#fipy.terms.term.Term"><code class="docutils literal notranslate"><span class="pre">Term</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.term.Term.RHSvector"><code class="docutils literal notranslate"><span class="pre">Term.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__add__"><code class="docutils literal notranslate"><span class="pre">Term.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__and__"><code class="docutils literal notranslate"><span class="pre">Term.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__div__"><code class="docutils literal notranslate"><span class="pre">Term.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__eq__"><code class="docutils literal notranslate"><span class="pre">Term.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__hash__"><code class="docutils literal notranslate"><span class="pre">Term.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__mul__"><code class="docutils literal notranslate"><span class="pre">Term.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__neg__"><code class="docutils literal notranslate"><span class="pre">Term.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__pos__"><code class="docutils literal notranslate"><span class="pre">Term.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__radd__"><code class="docutils literal notranslate"><span class="pre">Term.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__rand__"><code class="docutils literal notranslate"><span class="pre">Term.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__repr__"><code class="docutils literal notranslate"><span class="pre">Term.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__rmul__"><code class="docutils literal notranslate"><span class="pre">Term.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__rsub__"><code class="docutils literal notranslate"><span class="pre">Term.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__sub__"><code class="docutils literal notranslate"><span class="pre">Term.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.__truediv__"><code class="docutils literal notranslate"><span class="pre">Term.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">Term.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">Term.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.copy"><code class="docutils literal notranslate"><span class="pre">Term.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">Term.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.justErrorVector"><code class="docutils literal notranslate"><span class="pre">Term.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.justResidualVector"><code class="docutils literal notranslate"><span class="pre">Term.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.matrix"><code class="docutils literal notranslate"><span class="pre">Term.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">Term.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.solve"><code class="docutils literal notranslate"><span class="pre">Term.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.term.Term.sweep"><code class="docutils literal notranslate"><span class="pre">Term.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.test">fipy.terms.test module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.transientTerm">fipy.terms.transientTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm"><code class="docutils literal notranslate"><span class="pre">TransientTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__add__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__and__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__div__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">TransientTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.copy"><code class="docutils literal notranslate"><span class="pre">TransientTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">TransientTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.matrix"><code class="docutils literal notranslate"><span class="pre">TransientTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">TransientTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.solve"><code class="docutils literal notranslate"><span class="pre">TransientTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.transientTerm.TransientTerm.sweep"><code class="docutils literal notranslate"><span class="pre">TransientTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.unaryTerm">fipy.terms.unaryTerm module</a></li>
<li><a class="reference internal" href="#module-fipy.terms.upwindConvectionTerm">fipy.terms.upwindConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.upwindConvectionTerm.UpwindConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms.vanLeerConvectionTerm">fipy.terms.vanLeerConvectionTerm module</a><ul>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.vanLeerConvectionTerm.VanLeerConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-fipy.terms">Module contents</a><ul>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__cause__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__context__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__delattr__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__reduce__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__repr__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__setattr__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__setstate__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__str__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.__traceback__"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.args"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AbstractBaseClassError.with_traceback"><code class="docutils literal notranslate"><span class="pre">AbstractBaseClassError.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.AdvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">AdvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.CentralDifferenceConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">CentralDifferenceConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ConvectionTerm"><code class="docutils literal notranslate"><span class="pre">ConvectionTerm</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermCorrection.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.RHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__add__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__and__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__div__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__eq__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__hash__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__mul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__neg__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__pos__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__radd__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__rand__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__repr__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__rmul__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__rsub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__sub__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.__truediv__"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.copy"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.justErrorVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.justResidualVector"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.matrix"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.solve"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.DiffusionTermNoCorrection.sweep"><code class="docutils literal notranslate"><span class="pre">DiffusionTermNoCorrection.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitDiffusionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExplicitDiffusionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitUpwindConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExplicitUpwindConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__cause__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__context__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__delattr__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__reduce__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__repr__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__setattr__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__setstate__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__str__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.__traceback__"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.args"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExplicitVariableError.with_traceback"><code class="docutils literal notranslate"><span class="pre">ExplicitVariableError.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ExponentialConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ExponentialConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.FirstOrderAdvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">FirstOrderAdvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.HybridConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">HybridConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ImplicitDiffusionTerm"><code class="docutils literal notranslate"><span class="pre">ImplicitDiffusionTerm</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.copy"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.solve"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ImplicitSourceTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ImplicitSourceTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__cause__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__context__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__delattr__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__getattribute__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__reduce__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__repr__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__setattr__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__setstate__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__str__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.__traceback__"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.args"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.IncorrectSolutionVariable.with_traceback"><code class="docutils literal notranslate"><span class="pre">IncorrectSolutionVariable.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.PowerLawConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">PowerLawConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm"><code class="docutils literal notranslate"><span class="pre">ResidualTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__add__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__and__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__div__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.copy"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.matrix"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.solve"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.ResidualTerm.sweep"><code class="docutils literal notranslate"><span class="pre">ResidualTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__cause__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__context__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__delattr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__reduce__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__repr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__setattr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__setstate__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__str__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.__traceback__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.args"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableNumberError.with_traceback"><code class="docutils literal notranslate"><span class="pre">SolutionVariableNumberError.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__cause__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__context__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__delattr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__reduce__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__repr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__setattr__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__setstate__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__str__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.__traceback__"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.args"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.SolutionVariableRequiredError.with_traceback"><code class="docutils literal notranslate"><span class="pre">SolutionVariableRequiredError.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__cause__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__context__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__delattr__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__reduce__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__repr__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__setattr__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__setstate__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__str__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.__traceback__"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.args"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TermMultiplyError.with_traceback"><code class="docutils literal notranslate"><span class="pre">TermMultiplyError.with_traceback()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm"><code class="docutils literal notranslate"><span class="pre">TransientTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__add__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__and__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__div__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">TransientTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">TransientTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.copy"><code class="docutils literal notranslate"><span class="pre">TransientTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">TransientTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">TransientTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.matrix"><code class="docutils literal notranslate"><span class="pre">TransientTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">TransientTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.solve"><code class="docutils literal notranslate"><span class="pre">TransientTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.TransientTerm.sweep"><code class="docutils literal notranslate"><span class="pre">TransientTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.UpwindConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">UpwindConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.RHSvector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.RHSvector</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__add__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__add__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__and__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__and__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__div__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__div__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__eq__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__eq__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__hash__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__hash__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__mul__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__neg__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__neg__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__pos__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__pos__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__radd__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__radd__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__rand__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rand__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__repr__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__rmul__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rmul__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__rsub__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__rsub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__sub__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__sub__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.__truediv__"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.__truediv__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.cacheMatrix"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.cacheMatrix()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.cacheRHSvector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.cacheRHSvector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.copy"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.copy()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.getDefaultSolver"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.getDefaultSolver()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.justErrorVector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.justErrorVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.justResidualVector"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.justResidualVector()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.matrix"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.matrix</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.residualVectorAndNorm"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.residualVectorAndNorm()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.solve"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.solve()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VanLeerConvectionTerm.sweep"><code class="docutils literal notranslate"><span class="pre">VanLeerConvectionTerm.sweep()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError</span></code></a><ul>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__cause__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__cause__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__context__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__delattr__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__delattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__getattribute__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__getattribute__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__reduce__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__repr__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__repr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__setattr__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__setattr__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__setstate__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__str__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__str__()</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__suppress_context__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__suppress_context__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.__traceback__"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.__traceback__</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.args"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.args</span></code></a></li>
<li><a class="reference internal" href="#fipy.terms.VectorCoeffError.with_traceback"><code class="docutils literal notranslate"><span class="pre">VectorCoeffError.with_traceback()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
<div class="sphinxsidebarsection">
  <h4>Previous topic</h4>
  <p class="topless"><a href="fipy.steppers.html"
                        title="previous chapter">fipy.steppers package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fipy.tests.html"
                        title="next chapter">fipy.tests package</a></p>
</div>
  <div class="sphinxsidebarsection">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/fipy/generated/fipy.terms.rst.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
  </div>
<div class="sphinxsidebarsection">
<div id="searchbox" style="display: none" role="search">
  <div data-layout-content-preview-placeholder-label="&quot;Sphinx
  Search&quot; field" class="nist-block nist-block--search">
  <h2>Quick search</h2>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
  </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
<div class="sphinxsidebarsection" id="contact-wrapper">
  
        <div data-layout-content-preview-placeholder-label="&quot;Related
        organization tree&quot; views block" class="nist-block nist-block--org">
          
          <h2 class="nist-block__title">Organizations</h2>
              
              <div class="views-element-container"><div
              class="js-view-dom-id-70b0923f677edbe3dda361030ef8dc373cd0ca94065c39cfd81338de767f1019">

            <div class="nist-related-orgs"><div class="term-tree-list"><ul
            class="term"><li class="selected"><a
            href="https://www.nist.gov/nist-organizations/nist-headquarters" hreflang="en">NIST
            Headquarters</a><ul class="term"><li class="selected"><a
            href="https://www.nist.gov/nist-organizations/nist-headquarters/laboratory-programs"
            hreflang="en">Laboratory Programs</a><ul class="term"><li
            class="selected"><a
            href="https://www.nist.gov/nist-organizations/nist-headquarters/laboratory-programs/material-measurement-laboratory"
            hreflang="en">Material Measurement Laboratory</a>
			<ul
			class="term"><li
			class="selected"><a href="https://www.nist.gov/mml/msed"
			hreflang="en">Materials Science and Engineering
			Division</a></li><li
			class="selected"><a href="https://www.nist.gov/mml/ctcms"
			hreflang="en">Center for Theoretical and
			              Computational Materials Science</a></li></ul>
                          </li></ul></li></ul></li></ul></div></div>
          <div class="nist-related-orgs"></div>
          <div class="nist-related-orgs"></div>



        </div>
        </div>

          </div>


          <div data-layout-content-preview-placeholder-label="&quot;NIST
          Staff&quot; field" class="nist-block nist-block--contact">

          <h2 class="nist-block__title">NIST Staff</h2>

                  <div class="nist-field nist-field--label-hidden
                  nist-field--link-list entity-reference nist-field__items
                  nist-field--no-margin">
                            <div class="nist-field__item
                            nist-field--no-margin"><a
                            href="https://www.nist.gov/people/jonathan-e-guyer"
                            hreflang="en">Jonathan E. Guyer</a></div>
                                <div class="nist-field__item
                                nist-field--no-margin"><a
                                href="https://www.nist.gov/people/daniel-wheeler"
                                hreflang="en">Daniel Wheeler</a></div>
                                <div class="nist-field__item
                                nist-field--no-margin"><a
                                href="https://www.nist.gov/people/james-warren"
                                hreflang="en">James A. Warren</a></div>
                  </div>


          </div>

          <div data-layout-content-preview-placeholder-label="&quot;Contact&quot; field"
          class="nist-block nist-block--contact nist-block--mail">

          <h2 class="nist-block__title">
          <a class="" href="../../documentation/CONTACT.html" style="">Contact</a>
          </h2>

          </div>

</div>
        </div>
      </div>
      <div class="clearer"></div>
  </aside>
        </div>
      </div>

      <div class="panel-region--postface">
      <div class="inner region-inner inside">
        
<div class="pane pane--nist-node-date-pane" >

    </div>
      </div>
    </div>

        </section>
        </div>
      </div>

      </div>  
    </div>          

    </div>

  </div>

</div>


  


  <!-- Taken from https://www.filamentgroup.com/lab/html-includes/#another-demo%3A-including-another-html-file -->
  <iframe src="../../_static/ntd2d_menu.html" onload="this.before((this.contentDocument.body||this.contentDocument).children[0]);this.remove()"></iframe>
    </div>
  </body>
</html>